# Замыкания и объекты (You don't know JavaScript by Kyle Simpson)

## Область видимости (Лексическая область видимости)

Лексической областью видимости называется область видимости, определяемая на стадии лексического анализа. Другими словами, лексическая область видимости определяется тем, где вы разместили переменные и блоки видимости во время написания программы, а следовательно, (в основном) жестко фиксируется на момент обработки вашего кода лексическим анализатором.

Лексическая область видимости определяется рашениями о том, где объявляются функции, принимаемыми во время написания программы. Фаза лексичего анализа в процессе компиляции располагает информацией о том, где и как объявлены все идентификаторы, - а следовательно, может спрогнозировать их поиск во время выполнения.

В JavaScript существуют два механизма, которые могут "исказить" лексическую область видимости: eval(...) и with. Первый может изменить существующую лексическую область видимости (во время выполнения), обрабатывая строку "кода" с одним или несколькими объявленями. Второй фактически создает новую лексическую область видимости (снова во время выполнения), интерпретируя ссылку на объект как область видимости, а свойства этого объекта - как идентификаторы в области видимости.

Недостаток этих механизмов в том, что они не ползволяют движку выполнить оптимизации на стадии компиляции связанные с поиском по областям видимости, потому что движок вынужден пессимистично считать, что такие оптимизации будут недействительными. При использовании любой их этих возможностей программа *будет* работать медленее. *Не используйте их.*

## IIFE

Пример объявления:

```js

(function IIFE() {
  console.log('iife');
})();

(function IIFE(){
  console.log('iife');
}());

```

Пример использования:

```js

var a = 2;

(function IIFE(def){
  def( window );
})(function def(global) {
  var a = 3;
  console.log(a); // 3
  console.log(global.a) // 2
});

```

## let и const

Ключевое слово `let` и `const` присоединяет объявление переменной к области видимости того блока, в которой оно содержится. Иначе говоря, `let` и `const` неявно заимствует область видимости любого блока для объявления своей переменной.

Пример:

```js

var foo = true;

if (foo) {
  let bar = foo * 2;
  bar = something( bar );
  console.log( bar );
}

console.log( bar ); // ReferenceError

```

## Замыкания

Замыкание - способность функции запомнить свою лексическую область видимости и обращаться к ней даже тогда, когда функция выполняется вне своей лексической области видимости.

Несколько примеров помогут проиллюстрировать это определение.

```js

function foo() {
  var a = 2;
  
  function bar() {
    console.log( a ); // 2
  }
  
  bar();
}

foo();

```

Функция `bar()` обладает доступом к переменной `a` во внешней области видимости из-за правил поиска лексической области видимости (в данном случае это поиск RHS-ссылки).

Это и есть замыкание?

Чисто с технической точки зрения... *возможно*. Но если вспомнить наше приведенное выше определение "того, что вам нужно знать"... не со всем. Я думаю, что обращение `bar()` к `a` лучшего всего объясняется правилами поиска лексической области видимости, а эти правила являются лишь *составной частью* (хотя и важной) того, что называется замыканием.

С чисто теоретической точки зрения о приведенном фрагменте можно сказать, что функция `bar()` обладает *замыканием* над областями видимости `foo()` (а на самом деле и над остальными областями видимости, доступными для нее, например, глобальной областью видимости в данном случае). Если взглянуть на ситуацию несколько иначе, можно сказать, что `bar()` обладает замыканием над областью видимости `foo()`. Почему? Потому что функция `bar()` вложена в `foo()`. Просто и понятно.

Однако замыкания, определяемые таким образом, не видны напрямую, и мы не видим использования замыкания в этом фрагменте. Лексическая область видимости хорошо видна, но замыкание остается загадочной неуловимой тенью где-то за кодом. 

Давай рассмортрим код, который выводит замыкание на свет:

```js

function foo() {
  var a = 2;
  
  function bar() {
    console.log( a );
  }
  
  return bar;
}

var baz = foo();

baz(); // 2 -- вы только что увидели замыкание.

```

## this

Связывание `this` происходит в момент вызова функции, и то, на *что* ссылается `this`, определяется исключительно местов вызова, из которого была вызвана функция.

## Запрет расширения

**preventExtensions**

Если вы хотите запретить возможность добавления новых свойств в объект, но оставить остальные свойства объекта без изменений, вызовите `Object.preventExtensions( .. )`:

```js

var myObject = {
  a: 2,
};

Object.preventExtensions( myObject );

myObject.b = 3;
myObject.b; // undefined
```

**Seal**

`Object.seal( .. )` создает "запечатанный" объект; функция получает существующий объект и фактически вызывает для него `Object.preventExtensions( .. )` но также все существующие свойства получают пометку `configurable:false`.

Таким образом, к объекту не только нельзя добавлять новый свойства, но и также нельзя изменять конфигурацию или удалять существующие свойства (хотя вы можете изменять их значения).

**Freeze**

`Object.freeze( .. )` создает "замороженный" объект; функция получает существующий объект и фактически вызывает для него `Object.seal( .. )`, но также все свойства доступа к данным получают пометку `writable:false`, так что их значения не могут быть изменены.
